name: Instagram + YouTube Bot

on:
  schedule:
    # All cron times in UTC. IST = UTC + 5:30
    # Strategy: many small sessions = human phone-check pattern
    # 1 post/day at prime time (both IG + YT) + engagement spread throughout
    # Each session has 0-4min startup jitter built into the code
    #
    # YouTube sessions interspersed with Instagram sessions
    # YT engagement 4x/day, YT replies 2x/day
    - cron: '30 1 * * *'   # 07:00 IST — morning engagement (wake up)
    - cron: '15 2 * * *'   # 07:45 IST — explore (morning scroll)
    - cron: '0 3 * * *'    # 08:30 IST — hashtags
    - cron: '30 3 * * *'   # 09:00 IST — replies
    - cron: '15 4 * * *'   # 09:45 IST — stories
    - cron: '0 5 * * *'    # 10:30 IST — YT engage (morning YouTube browse)
    - cron: '30 5 * * *'   # 11:00 IST — explore
    - cron: '0 6 * * *'    # 11:30 IST — hashtags
    - cron: '30 6 * * *'   # 12:00 IST — explore (lunch break)
    - cron: '0 7 * * *'    # 12:30 IST — hashtags
    - cron: '30 7 * * *'   # 13:00 IST — YT replies (respond to comments)
    - cron: '0 8 * * *'    # 13:30 IST — hashtags
    - cron: '30 8 * * *'   # 14:00 IST — stories
    - cron: '15 9 * * *'   # 14:45 IST — explore
    - cron: '0 10 * * *'   # 15:30 IST — hashtags
    - cron: '30 10 * * *'  # 16:00 IST — replies
    - cron: '15 11 * * *'  # 16:45 IST — YT engage (afternoon YouTube)
    - cron: '0 12 * * *'   # 17:30 IST — explore
    - cron: '30 12 * * *'  # 18:00 IST — stories
    - cron: '0 13 * * *'   # 18:30 IST — hashtags
    - cron: '30 13 * * *'  # 19:00 IST — PUBLISH (IG + YT) + hashtags (PRIME TIME)
    - cron: '0 14 * * *'   # 19:30 IST — explore
    - cron: '30 14 * * *'  # 20:00 IST — YT engage (evening YouTube)
    - cron: '15 15 * * *'  # 20:45 IST — replies
    - cron: '0 16 * * *'   # 21:30 IST — explore (evening wind-down)
    - cron: '30 16 * * *'  # 22:00 IST — maintenance (unfollow)
    - cron: '0 17 * * *'   # 22:30 IST — YT replies (evening reply session)
    - cron: '30 17 * * *'  # 23:00 IST — maintenance
    - cron: '0 18 * * *'   # 23:30 IST — daily report

  workflow_dispatch:
    inputs:
      session:
        description: 'Session type'
        required: true
        default: 'full'
        type: choice
        options: [morning, replies, hashtags, explore, maintenance, stories, report, full, yt_engage, yt_replies, yt_full]
      publish:
        description: 'Also publish a post?'
        type: boolean
        default: false

# Only one bot run at a time (queue others, don't cancel)
concurrency:
  group: instagram-bot
  cancel-in-progress: false

permissions:
  contents: write

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python 3.13
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'
          cache: pip

      - name: Install dependencies
        run: pip install -r requirements.txt

      # Restore Instagram session from cache (avoids re-login each run)
      - name: Restore session cache
        id: cache
        uses: actions/cache/restore@v4
        with:
          path: instagram_influencer/.ig_session.json
          key: ig-session
          restore-keys: ig-session

      # Seed session from secret if no cache was restored
      - name: Seed session from secret
        run: |
          if [ -f instagram_influencer/.ig_session.json ]; then
            echo "Session restored from cache"
          elif [ -n "$SESS_B64" ]; then
            echo "$SESS_B64" | base64 -d > instagram_influencer/.ig_session.json
            echo "Seeded session from secret"
          else
            echo "WARNING: No session available — bot will attempt fresh login"
          fi
        env:
          SESS_B64: ${{ secrets.INSTAGRAM_SESSION_B64 }}

      # Create .env from the DOTENV secret
      - name: Create .env
        run: echo "${{ secrets.DOTENV }}" > instagram_influencer/.env

      # Determine which session to run based on the trigger
      - name: Determine session
        id: session
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "type=${{ inputs.session }}" >> $GITHUB_OUTPUT
            if [ "${{ inputs.publish }}" = "true" ]; then
              echo "publish=true" >> $GITHUB_OUTPUT
            else
              echo "publish=false" >> $GITHUB_OUTPUT
            fi
          else
            # Scheduled run — map UTC hour+minute to session type
            # Uses HHMM format for precise mapping with multiple sessions per hour
            # Only 19:00 IST (UTC 1330) publishes — 1 post/day like a normal person
            HHMM=$(date -u +%H%M)
            case "${HHMM}" in
              013*) echo "type=morning"     >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              021*) echo "type=explore"     >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              030*) echo "type=hashtags"    >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              033*) echo "type=replies"     >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              041*) echo "type=stories"     >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              050*) echo "type=yt_engage"   >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              053*) echo "type=explore"     >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              060*) echo "type=hashtags"    >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              063*) echo "type=explore"     >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              070*) echo "type=hashtags"    >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              073*) echo "type=yt_replies"  >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              080*) echo "type=hashtags"    >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              083*) echo "type=stories"     >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              091*) echo "type=explore"     >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              100*) echo "type=hashtags"    >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              103*) echo "type=replies"     >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              111*) echo "type=yt_engage"   >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              120*) echo "type=explore"     >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              123*) echo "type=stories"     >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              130*) echo "type=hashtags"    >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              133*) echo "type=hashtags"    >> $GITHUB_OUTPUT; echo "publish=true"  >> $GITHUB_OUTPUT ;;
              140*) echo "type=explore"     >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              143*) echo "type=yt_engage"   >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              151*) echo "type=replies"     >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              160*) echo "type=explore"     >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              163*) echo "type=maintenance" >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              170*) echo "type=yt_replies"  >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              173*) echo "type=maintenance" >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              180*) echo "type=report"      >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
              *)    echo "type=hashtags"    >> $GITHUB_OUTPUT; echo "publish=false" >> $GITHUB_OUTPUT ;;
            esac
          fi

      - name: Show session info
        run: |
          echo "Session: ${{ steps.session.outputs.type }}"
          echo "Publish: ${{ steps.session.outputs.publish }}"
          echo "Trigger: ${{ github.event_name }}"

      # Run the bot (continue-on-error so state still gets committed)
      - name: Run bot
        id: bot
        continue-on-error: true
        run: |
          cd instagram_influencer
          FLAGS="--session ${{ steps.session.outputs.type }}"
          if [ "${{ steps.session.outputs.publish }}" = "false" ]; then
            FLAGS="$FLAGS --no-publish --no-generate"
          fi
          echo "Running: python orchestrator.py $FLAGS"
          python orchestrator.py $FLAGS

      - name: Check bot result
        if: steps.bot.outcome == 'failure'
        run: echo "::warning::Bot run failed — check logs above"

      # Save updated session to cache
      - name: Save session cache
        if: always()
        uses: actions/cache/save@v4
        with:
          path: instagram_influencer/.ig_session.json
          key: ig-session-${{ github.run_id }}

      # Commit updated state files + session back to the repo
      - name: Commit state
        if: always()
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -f instagram_influencer/engagement_log.json \
                     instagram_influencer/followers.json \
                     instagram_influencer/content_queue.json \
                     instagram_influencer/highlights.json \
                     instagram_influencer/daily_report.md \
                     instagram_influencer/.ig_session.json \
                     "instagram_influencer/generated_images/IMAGE_PROMPTS.md" \
                     "instagram_influencer/generated_images/pending/" 2>/dev/null || true
          git diff --staged --quiet || (
            git commit -m "bot: state update $(date -u +%Y-%m-%dT%H:%M:%SZ) [${{ steps.session.outputs.type }}]"
            git push
          )
